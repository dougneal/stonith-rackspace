#!/usr/bin/python

import sys, re, pyrax, novaclient

sys.path.append("/usr/share/fence")
from fencing import *

debug_fh = None

def log(level, message):
  global debug_fh

  if debug_fh != None:
    debug_fh.write(message+"\n")

  if level == 'error':
    sys.stderr.write(message+"\n")

  if level == 'notice':
    sys.stdout.write(message+"\n")

def reboot(conn, options):
  log('debug', 'Rebooting!')

  try:
    conn.reboot('hard')

  except Exception as e:
    log('error', "Caught Exception while rebooting server: "+str(e))
    fail(EC_STATUS)

def get_server_status(server, options):
  log('debug', 'Getting server status; target status was '+options['-o'])

  # Re-login to API - for some reason if you don't do this, the server is reported
  # as ACTIVE, even during the reboot!
  server = rsc_get_server(options)

  try:
    status = server.status
    log('debug', 'Server status query returned '+status)

  except Exception as e:
    log('error', "Caught Exception obtaining server status: "+str(e))
    fail(EC_STATUS)

  return status

def rsc_get_server(options):
  username    = options['-l']
  api_key     = options['-p']
  region      = options['-r']
  server_name = options['-s']

  try:
    log('debug', 'Connecting to Rackspace Cloud API')
    pyrax.set_setting('identity_type', 'rackspace')
    pyrax.set_credentials(username, api_key = api_key, region = region)
    log('debug', 'Enumerating Cloud Servers and locating '+options['-s'])
    cs = pyrax.cloudservers
    server = cs.servers.find(name=options["-s"])

  except pyrax.exceptions.AuthenticationFailed:
    log('error', "Authentication failed for account "+username)
    fail(EC_LOGIN_DENIED)

  except novaclient.exceptions.NotFound:
    log('error', "Server "+server_name+" not found")
    fail(EC_STATUS)

  return server

# Override the fence_action method given in fencing.py which doesn't 
# correctly handle fencing devices that only provide a reboot command

# we can probably lose the server argument to this method as we re-fetch the object for each operation anyway
def fence_action(server, options, reboot, get_server_status):
  action        = options['-o']
  server_name   = options['-s']
  delay         = int(options['-f'])
  power_wait    = int(options['-G'])
  timeout       = int(options['-g'])
  safe_states   = ['HARD_REBOOT','DELETED','SUSPENDED']

  status = get_server_status(server, options)

  if action == 'monitor':
    # The STONITH device is considered healthy if it can successfully report the server's status.
    # We have already polled for the status. If this had failed we would have bailed out by now,
    # so just return true for this action and leave it at that
    log('debug', 'Monitor action called')
    return True
  
  elif action == 'status':
    log('debug', 'Status action called')
    log('notice', "Server {0} status is {1}".format(server,status))
    return True

  elif action == 'list':
    log('debug', 'List action called')
    log('notice', server_name)
    return True

  elif (action == 'on' or action == 'off' or action == 'reboot'):
    if (status in safe_states):
      log('notice', 'Server {0} status is {1}, no action required'.format(server_name, status))
      return True
    else:
      log('notice', 'Server {0} status is {1}, sending reboot command'.format(server_name, status))

      # wait for time period specified by --delay
      log('debug', 'Waiting {0} seconds before fencing'.format(delay))
      time.sleep(delay)
      reboot(server, options)

      # wait for -G, --power-wait  time period before entering polling loop
      log('debug', 'Waiting {0} seconds before polling server status'.format(power_wait))
      time.sleep(power_wait)

      # poll every second up to a maximum of -g seconds before failing
      for i in xrange(power_timeout):
        log('debug', 'Polling server state, attempt {0} of {1}'.format(i, power_timeout))
        status = get_server_status(server, options)
        if (status in safe_states):
          return True
        else:
          time.sleep(1)
      
      log('error', 'Timed out waiting for server to reach a safe state')
      fail(EC_TIMED_OUT)

  return False

def main():
  device_opt = [ "help", "version", "agent", "quiet", "verbose", "debug",
      "action", "login", "rsc_apikey", "rsc_region", "rsc_authurl", "server",
      "power_timeout", "power_wait" ]

  rsc_opts = {
    "login" : {
      "getopt"    : "l:",
      "longopt"   : "rsc-username=",
      "help"      : "-l, --rsc-username=<username>  Username of Rackspace Cloud account",
      "required"  : "1",
      "shortdesc" : "Username of Rackspace Cloud account",
      "order"     : 1
    },
    "rsc_apikey" : {
      "getopt"    : "p:",
      "longopt"   : "rsc-apikey=",
      "help"      : "-p, --rsc-apikey=<api key>     Rackspace Cloud API key",
      "required"  : "1",
      "shortdesc" : "API Key for Rackspace Cloud account",
      "order"     : 1
    },
    "rsc_region" : {
      "getopt"    : "r:",
      "longopt"   : "rsc-region=",
      "help"      : "-r, --rsc-region=<region>      Rackspace Cloud Region (DFW,ORD,IAD,LON,SYD)",
      "required"  : "1",
      "shortdesc" : "Rackspace Cloud Region (DFW,ORD,IAD,LON,SYD)",
      "order"     : 1
    },
    "rsc_authurl" : {
      "getopt"    : "",
      "longopt"   : "rsc-authurl=",
      "help"      : "--rsc-authurl=<authurl>        Rackspace Cloud authentication URL",
      "required"  : "0",
      "shortdesc" : "Override the API's default URL used to authenticate to the cloud service",
      "order"     : 1
    },
  	"server" : {
  	  "getopt"    : "s:",
  	  "longopt"   : "server",
  	  "help"      : "-s, --server=<server>          Name of Cloud Server",
  	  "shortdesc" : "Cloud server name",
  	  "required"  : "0",
  	  "default"   : "",
  	  "order"     : 1
  	}
  }

  all_opt.update(rsc_opts)
  options = check_input(device_opt, process_input(device_opt))

  #import pprint
  #pp = pprint.PrettyPrinter()
  #pp.pprint(options)
  #pdb.set_trace()

  global debug_fh
  if 'debug_fh' in options:
    debug_fh = options["debug_fh"]
  
  docs = { }
  docs["shortdesc"] = "Fence agent for Rackspace Cloud"
  docs["longdesc"]  = "fence_rackspace is a fencing agent which uses the Rackspace Cloud API"
  docs["vendorurl"] = "http://www.rackspace.com/"
  show_docs(options, docs)

  log('debug', 'Action invoked was '+options['-o']+' with target '+options['-s'])

  conn = rsc_get_server(options)
  if fence_action(conn, options, reboot, get_server_status):
    log('notice', 'Success')
    sys.exit(0)
  else:
    log('error', 'Unexpected error: fence_action returned False')
    fail(EC_STATUS)

if __name__ == "__main__":
  main()

